[{"content":"During work on project pl-k8s-kubernetes, I encounter an issue with the unit test, which can\u0026rsquo;t pass, here is the example shows what\u0026rsquo;s wrong with that.\nFirst create a source code with static method and named this file as aws_service_utils.py\nimport boto3 import json class AwsSecretManager: @staticmethod def create_secret(secret_name, json_content): secretsmanager_client = boto3.client(\u0026#39;secretsmanager\u0026#39;) # Create a secret response = secretsmanager_client.create_secret( Name=secret_name, # Name of the secret SecretString=json.dumps(json_content) # Secret data as a JSON string ) return response @staticmethod def delete_secret(secret_id): secretsmanager_client = boto3.client(\u0026#39;secretsmanager\u0026#39;) # Create a secret response = secretsmanager_client.delete_secret( Name=secret_name, # Name of the secret ) return response Second crate a method based on this method, backup_delete_secret.py\nfrom aws_service_utils import AwsSecretManager as SM def operator(secret_name, json_content): print(\u0026#34;Create secret\u0026#34;) response = SM.create_secret(secret_name, json_content) if response: SM.delete_secret(secret_name) print(\u0026#39;Delete secret success\u0026#39;) else: print(\u0026#39;Create secret fail, no need to delete secret\u0026#39;) Third create unittest cases based on those two methods\nfrom mock import patch, Mock import boto3 import unittest import sys sys.path.append(\u0026#34;.\u0026#34;) from backup_delete_secret import operator import aws_service_utils class TestBackupAndDelete(unittest.TestCase): @patch(\u0026#39;aws_service_utils.AwsSecretManager.create_secret\u0026#39;) @patch(\u0026#39;aws_service_utils.AwsSecretManager.delete_secret\u0026#39;) def test_operator_alway_work(self, mock_delete, mock_create): operator(\u0026#34;test\u0026#34;, { \u0026#34;name\u0026#34;:\u0026#34;wguan\u0026#34; }) mock_create.return_value = { \u0026#34;arn\u0026#34;:\u0026#34;1234\u0026#34; } self.assertEqual(mock_create.call_count, 1) self.assertEqual(mock_delete.call_count, 1) def test_operator_related_order(self): aws_service_utils.AwsSecretManager.create_secret = Mock(return_value={ \u0026#34;arn\u0026#34;: \u0026#34;1234\u0026#34; }) aws_service_utils.AwsSecretManager.delete_secret = Mock() operator(\u0026#34;test\u0026#34;, { \u0026#34;name\u0026#34;:\u0026#34;wguan\u0026#34; }) self.assertEqual(aws_service_utils.AwsSecretManager.create_secret.call_count, 1) self.assertEqual(aws_service_utils.AwsSecretManager.delete_secret.call_count, 1) In the above we have defined two similar methods, one is use patch to define a mock, it will release the mock object after the unit test finish, but if we define a function to mock object as follow\naws_service_utils.AwsSecretManager.create_secret = Mock(return_value={ \u0026#34;arn\u0026#34;: \u0026#34;1234\u0026#34; }) aws_service_utils.AwsSecretManager.delete_secret = Mock() it won\u0026rsquo;t release this static method, you can verify use the following method to verify. If you write unit test with patch method, the following will seccuess, but otherwise the following method may fail. But it may also success, this is relate another question, how does nose2 load unittest cases. This can be verify by yourself. If you want to let the case work well, there is another metod to fix, reload the package.\nimport boto3 import unittest import sys sys.path.append(\u0026#34;.\u0026#34;) from moto import mock_secretsmanager from aws_service_utils import AwsSecretManager as SM class TestAwsSecretManager(unittest.TestCase): @mock_secretsmanager def test_creat_secret(self): response = SM.create_secret(\u0026#34;test\u0026#34;, { \u0026#34;name\u0026#34;: \u0026#34;wguan\u0026#34; }) self.assertEqual(response[\u0026#39;ResponseMetadata\u0026#39;][\u0026#39;HTTPStatusCode\u0026#39;], 200) Summary:\nFor static method, never assign Mock object to static function, it will effect all the unit test after this case has been called The order of nose2 load unit test cases is related the name of case name Import AwsSecretManager in the last file, but it doesn\u0026rsquo;t import again, the root cause is python only import once, so there is anthor method to fix it, just use importlib.reload(package) ","date":"2023-05-14T10:11:13+08:00","permalink":"https://wguansky.github.io/blog/post/package_load/","title":"Python package load"},{"content":"Description Terraform is a very useful tool which can help us to deploy resource on Cloud such as Aws, Azure, and Google, and it also support deploy k8s.\nInstall Here is the document how to install terraform:\n","date":"2023-03-03T11:50:47+08:00","permalink":"https://wguansky.github.io/blog/post/terraform/","title":"Terraform"},{"content":"Description Ansible is an automation tools, you can use it to run automation on remote machine but it does\u0026rsquo;t support run on Windows, it only supports run on Linux machine. There is a very important feature, It doesn\u0026rsquo;t require the target machine to install ansible agent, it only requres you install ansible on the managment machine\nInstall Ansible depends on python, so if you want to install ansible, you must first install python, it support python2.7 and python3, here is the document how to install Ansible.\nUse Anaislbe Here is the document, which can be used to study how to learn ansible, it\u0026rsquo;s from KodeKloud and the Materials\n","date":"2023-03-03T10:41:06+08:00","permalink":"https://wguansky.github.io/blog/post/ansible/","title":"Ansible"},{"content":"package main import ( \u0026#34;fmt\u0026#34; \u0026#34;strings\u0026#34; ) func contact_str() { first_name := \u0026#34;Wei\u0026#34; last_name := \u0026#34;Guan\u0026#34; full_name := fmt.Sprintf(\u0026#34;%s %s\u0026#34;, first_name, last_name) fmt.Println(full_name) } func builder_str() { var str strings.Builder str.WriteString(\u0026#34;Wei \u0026#34;) str.WriteString(\u0026#34;Guan\u0026#34;) fmt.Println(str.String()) } func main() { contact_str() builder_str() } ","date":"2023-02-09T17:05:19+08:00","permalink":"https://wguansky.github.io/blog/post/contact_str/","title":"Contact_str"},{"content":"Read information from console is very important, here is a simple way to read message from conosle\nfmt read package main import ( \u0026#34;fmt\u0026#34; ) func main() { var message string fmt.Print(\u0026#34;Please input the message:\u0026#34;) fmt.Scan(\u0026amp;message) } stdin read package main import ( \u0026#34;bufio\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { reader := bufio.NewReader(os.Stdin) fmt.Print(\u0026#34;Input your name: \u0026#34;) name, err := reader.ReadString(\u0026#39;\\n\u0026#39;) if err != nil { log.Fatal(err) } fmt.Println(name) } ","date":"2023-02-09T15:24:26+08:00","permalink":"https://wguansky.github.io/blog/post/read_console/","title":"Read_console"},{"content":"Read File Read content from a file, string, or bytes are very important for any program language. In this article, we have showed the following package to read file:\nos ioutil If you want to read from buffer, you can use bufio to read file or string. At the same time you also can use strings, bytes to read string and []byte\npackage main import ( \u0026#34;bufio\u0026#34; \u0026#34;bytes\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;strings\u0026#34; ) func ReadString(s string) { reader := strings.NewReader(s) bytes := make([]byte, 50) for { n, err := reader.Read(bytes) if err != nil { break } else { fmt.Println(string(bytes[:n])) } } } func ReadBytes(b []byte) { reader := bytes.NewReader(b) bytes := make([]byte, 50) for { n, err := reader.Read(bytes) if err != nil { break } else { fmt.Println(string(bytes[:n])) } } } func ReadFileWithBuffer(filename string) error { f, err := os.Open(filename) if err != nil { log.Fatal(err) } reader := bufio.NewReader(f) bytes := make([]byte, 50) for { n, err := reader.Read(bytes) if err != nil { break } else { fmt.Println(string(bytes[:n])) } } return nil } func ReadFile(filename string) error { data, err := os.ReadFile(filename) if err != nil { return err } fmt.Println(string(data)) return nil } func ReadFileWithioutil(filename string) error { data, err := ioutil.ReadFile(filename) if err != nil { return err } fmt.Println(string(data)) return nil } func main() { file := \u0026#34;./temp.txt\u0026#34; err := ReadFile(file) if err != nil { log.Fatal(err) } err = ReadFileWithioutil(file) if err != nil { log.Fatal(err) } err = ReadFileWithBuffer(file) if err != nil { log.Fatal(err) } data, err := os.ReadFile(file) if err != nil { log.Fatal(err) } ReadBytes(data) ReadString(string(data)) } File Exists In this code, we will use os.Stat to get the file properties, and then check the error type\npackage main import ( \u0026#34;errors\u0026#34; \u0026#34;fmt\u0026#34; \u0026#34;os\u0026#34; ) func file_exists(path string) bool { _, err := os.Stat(path) return errors.Is(err, os.ErrNotExist) } func main() { fmt.Println(file_exists(\u0026#34;./main.go\u0026#34;)) fmt.Println(file_exists(\u0026#34;./main1.go\u0026#34;)) } Walk Dir Here is the method to go walk all the dir with deep iteration func walk_dir(path string) { dirInf, err := os.Stat(path) if errors.Is(err, os.ErrNotExist) { panic(err) } if !dirInf.IsDir() { fmt.Println(dirInf.Name()) return } dir_entires, err := os.ReadDir(path) if err != nil { panic(err) } for _, dir := range dir_entires { walk_dir(filepath.Join(path, dir.Name())) } } Walk dir with WalkFunc WalkDir function package main import ( \u0026#34;errors\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func walk_dir(path string) { dirInf, err := os.Stat(path) if errors.Is(err, os.ErrNotExist) { panic(err) } if !dirInf.IsDir() { log.Printf(\u0026#34;This is a file not a dir %s\\n\u0026#34;, filepath.Join(path, dirInf.Name())) return } filepath.WalkDir(path, func(path string, d fs.DirEntry, err error) error { if err != nil { return err } if !d.IsDir() { log.Printf(\u0026#34;%s\\n\u0026#34;, path) } return nil }) } func main() { walk_dir(\u0026#34;../..\u0026#34;) } Walk function package main import ( \u0026#34;errors\u0026#34; \u0026#34;io/fs\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; \u0026#34;path/filepath\u0026#34; ) func walk_dir(path string) { dirInf, err := os.Stat(path) if errors.Is(err, os.ErrNotExist) { panic(err) } if !dirInf.IsDir() { log.Printf(\u0026#34;This is a file not a dir %s\\n\u0026#34;, filepath.Join(path, dirInf.Name())) return } filepath.Walk(path, func(path string, d fs.FileInfo, err error) error { if err != nil { return err } if !d.IsDir() { log.Printf(\u0026#34;%s\\n\u0026#34;, path) } return nil }) } func main() { walk_dir(\u0026#34;../\u0026#34;) } Copy File package main import ( \u0026#34;io\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func CopyFileOnceRead(source, dest string) error { data, err := ioutil.ReadFile(source) if err != nil { return err } writer, err := os.OpenFile(dest, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0755) if err != nil { return err } _, err = writer.Write(data) return err } func CopyFileWithStream(source, dest string) error { reader, err := os.Open(source) if err != nil { return err } writer, err := os.OpenFile(dest, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0755) if err != nil { return err } _, err = io.Copy(writer, reader) return err } func CopyFileWithStreamBuf(source, dest string) error { reader, err := os.Open(source) if err != nil { return err } writer, err := os.OpenFile(dest, os.O_CREATE|os.O_APPEND|os.O_WRONLY, 0755) if err != nil { return err } var buf [2048]byte _, err = io.CopyBuffer(writer, reader, buf[:]) return err } func main() { // err := CopyFileOnceRead(\u0026#34;./main.go\u0026#34;, \u0026#34;./main1.go\u0026#34;) // if err != nil { // log.Fatalln(err) // } err := os.Remove(\u0026#34;./main1.go\u0026#34;) if err != nil { log.Println(err) } CopyFileWithStreamBuf(\u0026#34;./main.go\u0026#34;, \u0026#34;./main1.go\u0026#34;) } Rename file package main import ( \u0026#34;log\u0026#34; \u0026#34;os\u0026#34; ) func main() { err := os.Rename(\u0026#34;./main1.go\u0026#34;, \u0026#34;./main2.go\u0026#34;) if err != nil { log.Fatalln(err) } } ","date":"2023-02-08T23:25:31+08:00","permalink":"https://wguansky.github.io/blog/post/go_read/","title":"Go File Operator"},{"content":"Forward proxy: Reverse proxy:\n","date":"2023-02-07T14:38:24+08:00","permalink":"https://wguansky.github.io/blog/post/proxy/","title":"Proxy"},{"content":"Define Go var x []float64 // Slice x:=65 // This will given a default type var x: []float64={1,2,3} var x [12]float14 // array Rust let x = 18 let mut x = 19 let x:i32=19 ","date":"2023-02-01T13:26:14+08:00","permalink":"https://wguansky.github.io/blog/post/go_vs_rust/","title":"Go_vs_rust"},{"content":"Create Large File Here is the command how to create a large file:\nfsutil file createnew file_name file_size Get file size The file size if byte not k byte\n$v = Get-PSDrive C | Select-Object Free $v.free ","date":"2023-01-16T13:43:44+08:00","permalink":"https://wguansky.github.io/blog/post/create_large_file/","title":"PowerShell Command"},{"content":"This is my first time write a rust programm by myslef:\nuse rand::Rng; use std::cmp::Ordering; use std::io; fn main() { println!(\u0026#34;Generate a secret number!\u0026#34;); let secret_number = rand::thread_rng().gen_range(1..100); loop { println!(\u0026#34;Please input a number!\u0026#34;); let mut input = String::new(); match io::stdin().read_line(\u0026amp;mut input) { Ok(_) =\u0026gt; {}, Err(_) =\u0026gt; { println!(\u0026#34;Type error, please type again!\u0026#34;); continue; }, } let num: u32 = match input.trim().parse() { Ok(num) =\u0026gt; num, Err(_) =\u0026gt; { println!(\u0026#34;Please type a number!\u0026#34;); continue; } }; match num.cmp(\u0026amp;secret_number) { Ordering::Less =\u0026gt; { println!(\u0026#34;You input a less number\u0026#34;); } Ordering::Greater =\u0026gt; { println!(\u0026#34;You input a greate number\u0026#34;); } Ordering::Equal =\u0026gt; { println!(\u0026#34;You are win\u0026#34;); break; } } } } ","date":"2023-01-11T00:21:31+08:00","permalink":"https://wguansky.github.io/blog/post/first_rust/","title":"First_rust"},{"content":"Install rust analyzer In order to configure rust analyzer in vimspace, you must first install the analyzer in the console and then configure in the spacevim. Based on Install, run command:\nbrew install rust-analyzer Configure Spacevim Configure spacevim, you can refer doc spacevim, then it can work very well.\n","date":"2023-01-06T17:56:14+08:00","permalink":"https://wguansky.github.io/blog/post/rust_analyzer/","title":"Rust Analyzer"},{"content":"Everything is object in python, so class is aslo object named Metadata Calss.\nHow to use define and use metaclass The basic metadata class is type, you can define an object from this type.\nPythonClass = type(\u0026#39;class name\u0026#39;, (supper class,), attributes) The above will retruen a calss. If you want to define a new class, you can inhiert from type as follow:\nclass Single(type): pass Now Single is a new metadata class, then you can use it to define a new class.\nclass Logger(metaclass=Single): pass Then Logger will try to use Single to help create the class.\nWhat should we implement a metacalss In order to create an object or class, there are three special methods __new__, __init__, and __call__. When we initial an object, it will call new first to malloc the memory and then use init to set some properities. But what\u0026rsquo;s method __call__, it just a special method, when you call ClassName(*args, **kwargs), then it will call method __call__ automactically. So we can change the inital process when we create a class object.\nHere is an example, how to use meta calss define Single class.\nclass Single(type): _instances = {} def __call__(cls, *args, **kwargs): if cls not in cls._instances: cls._instances[cls] = super(SingletonMeta,cls).__call__(*args, **kwargs) return cls._instances[cls] Define object\nclass Logger(metaclass=Single): pass When you call Logger() to create an object, this it will call Single\u0026rsquo;s __new__, and __init__, then it will return an class object, then it will call __call__ method of metaclass. There is an very important notice: If you special __call__ method, then the methods __init__ and __new__ of object will never been call, if you want it still be called. For this case, it will call __init__ and __new__, because super class will call them automatically.\nExample Code #!/usr/bin/env python3 # -*- coding: utf-8 -*- #************************************************************************* # File Name: test.py # Author: Guan Wei # Mail: wguan@microstrategy.com # Created Time: Sun Oct 30 22:49:17 2022 #************************************************************************ class ClassA(type): def __new__(cls, name, base, dct): print(\u0026#34;metadata class\u0026#34;) return type.__new__(cls, name, base, dct) def __call__(cls, *args, **kwargs): print(\u0026#34;hello world!\u0026#34;) print(\u0026#39;call ClassA instance\u0026#39;) instance = cls.__new__() # instance.__new__() # instance.__init__() return instance class ClassB(object): __metaclass__ = ClassA def __init__(self): print(\u0026#34;Call classb init\u0026#34;) def __new__(cls): print(\u0026#34;calss classb new\u0026#34;) return object.__new__(cls) if __name__==\u0026#39;__main__\u0026#39;: x=ClassB() ","date":"2022-12-30T04:37:23+08:00","permalink":"https://wguansky.github.io/blog/post/metadata_class/","title":"Metadata Class"},{"content":"Hugo is a static web develop tool. This website is just use hugo to develop, here is the method how to publish it in github.\nPublish static web For static website, we can just use Git to publish it. Go to Setting -\u0026gt; Page and then set the page you want to publish, and then save it.\nPublish hugo Create two repos, one is Source repo and one is Page repo For Source repo, we set it as public, Page as private In the github account for Page, create a deploy key or personal key In the Source repo create a workflow and set the sceret with the personal token. Here is the workflow for Source:\nname: GitHub Pages on: push: branches: - main # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-22.04 concurrency: group: ${{ github.workflow }}-${{ github.ref }} steps: - uses: actions/checkout@v3 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: \u0026#39;0.107.0\u0026#39; extended: true - name: Build run: hugo - name: Deploy uses: peaceiris/actions-gh-pages@v3 if: ${{ github.ref == \u0026#39;refs/heads/main\u0026#39; }} with: personal_token: ${{ secrets.ACCESS_TOKEN }} publish_dir: ./docs publish_branch: main external_repository: wguansky/blog Then the code will be build in Source workflow and then push to Page, after it finished, Page\u0026rsquo;s workflow will build and deploy the page, then you can visit the hugo website.\n","date":"2022-12-29T15:27:52+08:00","permalink":"https://wguansky.github.io/blog/post/publish_hugo_in_github/","title":"Publish hugo websit on github"},{"content":"Unit test is very import to improve the code robust. Each time, when we do some changes or code refactor, we need to verify our code can work well. And those errors can be exposed in develop process not in the test process.\nTools For pythhon, we usually use two type of tools to run python test nose2 and pytest, and they both based on unittest. In my mind, if you want to test or debug only one unit case, I recommand to use pytest.\nMock Mock is very useful method to write unit test, and there is a very important and confuse about mock.\n@patch.object(Version, \u0026#39;validate_version\u0026#39;) @patch.object(Version, \u0026#39;get_version\u0026#39;) @patch(\u0026#39;pre_validation.linux.verify_linux_version.get_version_from_install_xml\u0026#39;) def test_verify_mstr_linux_version(self, m_install_xml, m_get_version, m_validate_version): m_install_xml.return_value = (\u0026#34;0.107.5044\u0026#34;, \u0026#34;false\u0026#34;) m_get_version.return_value = \u0026#34;version_short\u0026#34;, \u0026#34;version_build\u0026#34; m_validate_version.return_value = True return_result = verify_linux_version() self.assertTrue(return_result) Here you can see the order in from right to left not from left to right. For install_xml, you can see it use the absoulte path and this function is call in that file, not the function define in that file. ","date":"2022-12-29T13:35:43+08:00","permalink":"https://wguansky.github.io/blog/post/python_test/","title":"Python unit test"},{"content":"In our daily work, we may want to do some tasks, such as build or compile. There is a very useful tool task which can help us to define our work in a yaml file, then it can help us to run those commands. For remote, you can refer Ansible, which is a very useful tool for Linux automation.\nHere is an example for build mstrbak, in that repo, we define an internal task file as follow:\nversion: \u0026#39;3\u0026#39; tasks: clean: internal: true cmds: - rm -rf {{.TOOL}} build.txt lib {{.TOOL}}.exe {{.TOOL}}.zip build-linux: internal: true deps: [jar] cmds: - GOOS=linux GOARCH=amd64 go build -o {{.TOOL}} main.go - zip -r {{.TOOL}}.zip lib {{.CONFIG}}.yaml {{.TOOL}} - task: post-clean build-windows: internal: true deps: [jar] cmds: - GOOS=linux GOARCH=amd64 go build -o {{.TOOL}}.exe main.go - zip -r {{.TOOL}}.zip lib {{.CONFIG}}.yaml {{.TOOL}}.exe - task: post-clean test: cmds: - go test -v -gcflags=all=-l -count=1 */*.go jar: deps: [pom] cmds: - mvn clean dependency:copy-dependencies dependency:tree -DoutputFile=build.txt - mv lib/DBMigrator*.jar lib/DBMigrator.jar pom: deps: [clean] cmds: - cp ../dbmigrator/pom.xml . status: - test -f pom.xml post-clean: deps: [clean-pom] cmds: - rm -rf {{.TOOL}} build.txt lib {{.TOOL}}.exe clean-pom: interal: true cmds: - | if test {{.CLEAN_POM}} = true; then rm -rf pom.xml fi Then we define a task file refer the internal yaml file, which can work very well.\nversion: \u0026#39;3\u0026#39; includes: dbmigrator: taskfile: ./Taskfile-Internal.yaml dir: ./dbmigrator vars: TOOL: DBMigrator CONFIG: config CLEAN_POM: false backup: taskfile: ./Taskfile-Internal.yaml dir: ./backup vars: TOOL: mstrbak CONFIG: config CLEAN_POM: true restore: taskfile: ./Taskfile-Internal.yaml dir: ./restore vars: TOOL: restore CONFIG: restore CLEAN_POM: true tasks: build-linux: deps: [dbmigrator:build-linux, backup:build-linux, restore:build-linux] build-windows: deps: [dbmigrator:build-windows, backup:build-windows, restore:build-windows] test: deps: [dbmigrator:test, backup:test, restore:test] cmds: - | for t in \u0026#34;service\u0026#34; \u0026#34;logger\u0026#34; \u0026#34;utilities\u0026#34; do go test -v -gcflags=all=-l -count=1 $t/*.go done clean: deps: [dbmigrator:clean, backup:clean, restore:clean] You can also use make to do build and compile work. Current I always use shell or python to do build work, but task or make may more useful, in the future, I can try to convert them with task or make.\n","date":"2022-12-28T23:32:38+08:00","permalink":"https://wguansky.github.io/blog/post/gotask/","title":"Gotask"},{"content":"This article is about go unit test, in this article I will show some key and basic use for go.\nBasic The test file must named as XXXX_test.go2. The test function must named with TestXXXX, then it can be call when you try to run it. Test Type There are two type of unit test.\nBasic unit test, it will be like format TestXX(t *testing.T){} Benchmark test, it will be lke the format TestXXX(t *testing.B){} Run unit test go test -v -gcflags=all=-l -count=1 /.go\n-v will show all the code coverage -gcflags=all=-l which won\u0026rsquo;t optimizte the code, if not add this flag, some cases may fail -count=1 which means do nont enable cache, if enable this, it can improve the performance Run unit test in a container For go unit test, it may fail when you try to run unit test on a machine such as my mac, it may fail and show error permission denied, so we can mount our code into a go docker and then run our unit test code in docker, this is a very useful method to run unit test. Here is the command:\ndocker run -it -v /Users/wguan/work/code/study:/go --privileged docker.io/golang bash Unit test In order to write a good unit test, there are many things useful libraries which can help us.\nTestify For this package, the most use of this package is assert, we can use this package to assert many conditions.\nGomock This package can only mock interface, and if you want to mock a function or method, it can not work very well. And for this package it also requires to generate mock code, it can\u0026rsquo;t mock directly.\ngomonkey Gomonkey is the most useful package for go test, it can mock all of the type function, methods, interface and variable. But some platforms may not support, so you have to run those unit tests in a docker.\ngostub Gostub is used to mock variable.\nconvey convey is very useful and friendly unit test package, it can help us to print and shows case clearly.\nTest console There are some cases we print our result to the console, so we need to catch the output and compare the result, here is the example code.\nfunction code:\npackage test import \u0026#34;fmt\u0026#34; func MyPrint() { fmt.Print(\u0026#34;Hello World!\u0026#34;) } Test code:\npackage test import ( \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestMyPrint(t *testing.T) { rescueStdout := os.Stdout r, w, _ := os.Pipe() os.Stdout = w MyPrint() w.Close() out, _ := ioutil.ReadAll(r) os.Stdout = rescueStdout assert.Equal(t, string(out), \u0026#34;Hello World!\u0026#34;) } Fuzzy Test Fuzzy test just define some example cases, then it will generate other cases.\n","date":"2022-12-28T22:26:58+08:00","permalink":"https://wguansky.github.io/blog/post/go_test/","title":"Go Test"},{"content":"This is a very useful tool, you can use it to help generate MySQL and Postgresql database schema just through this tool, for more information you can refer DBDigram\n","date":"2022-12-28T19:03:42+08:00","permalink":"https://wguansky.github.io/blog/post/dbdigram/","title":"DBdigram"},{"content":"Database Schema Migration In our daliy work, we will control the database version, but how to upgrade database schema or download database schma is very hard for our daliy work, there is a tool name dbmigration. In this tool, it provide cli and library for go. Now we can use it in PA and Provision Api to migrate database.\n","date":"2022-12-28T18:38:02+08:00","permalink":"https://wguansky.github.io/blog/post/dbmigration/","title":"DBmigration"},{"content":"Introduction Sometimes we can\u0026rsquo;t connect forigen website without proxy, we can set chrome with omega proxy, but for local we can\u0026rsquo;t use it. This document will introduce how to set proxy in terminate.\nSet proxy in terminal Add the following command in .bashrc or .zshrc file\nalias hp=\u0026#34;https_proxy=\\\u0026#34;http://10.27.7.110:8080\\\u0026#34; http_proxy=\\\u0026#34;http://10.27.7.110 :8080\\\u0026#34;\u0026#34; When you want to run a command need proxy, you should run the following command:\nhp shell_command Test hp curl cip.cc ","date":"2022-12-08T03:26:03+08:00","permalink":"https://wguansky.github.io/blog/post/terminal_proxy/","title":"How to set proxy for terminal"}]